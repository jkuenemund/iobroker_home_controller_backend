{
  "version": 3,
  "sources": ["../../../src/lib/services/snapshot-service.ts"],
  "sourcesContent": ["/* eslint-disable jsdoc/require-param, jsdoc/require-jsdoc */\n\nimport type { DeviceConfig, RoomConfig, SceneConfig, SnapshotPayload } from \"../websocket/types\";\n\n/**\n * Minimal adapter interface needed for snapshot building.\n */\nexport interface SnapshotAdapterDeps {\n\tlog: {\n\t\tdebug: (msg: string) => void;\n\t\tinfo: (msg: string) => void;\n\t\twarn: (msg: string) => void;\n\t\terror: (msg: string) => void;\n\t};\n\tconfig: {\n\t\tbasePath: string;\n\t\tscenesPath: string;\n\t};\n\tgetForeignStatesAsync: (pattern: string) => Promise<Record<string, ioBroker.State | null | undefined>>;\n\tgetForeignStateAsync: (id: string) => Promise<ioBroker.State | null | undefined>;\n\tsubscribeForeignStates: (pattern: string) => void;\n}\n\nexport class SnapshotService {\n\tprivate readonly adapter: SnapshotAdapterDeps;\n\n\tconstructor(adapter: SnapshotAdapterDeps) {\n\t\tthis.adapter = adapter;\n\t}\n\n\t/**\n\t * Build snapshot (devices + rooms + scenes) with provided seq reference\n\t */\n\tpublic async buildSnapshot(seq: number): Promise<SnapshotPayload> {\n\t\tconst [devices, rooms, scenes] = await Promise.all([this.getDevices(), this.getRooms(), this.getScenes()]);\n\t\treturn { devices, rooms, scenes, seq };\n\t}\n\n\tpublic async getDevices(): Promise<Record<string, DeviceConfig>> {\n\t\treturn this.fetchDevices();\n\t}\n\n\tpublic async getRooms(): Promise<Record<string, RoomConfig>> {\n\t\treturn this.fetchRooms();\n\t}\n\n\tpublic async getScenes(): Promise<Record<string, SceneConfig>> {\n\t\treturn this.fetchScenes();\n\t}\n\n\tpublic async validateSetState(\n\t\tdeviceId: string,\n\t\tcapability: string,\n\t\tstateId: string,\n\t): Promise<{ ok: boolean; reason?: string }> {\n\t\tconst devices = await this.fetchDevices();\n\t\tconst device = devices[deviceId];\n\t\tif (!device) {\n\t\t\treturn { ok: false, reason: \"UNKNOWN_DEVICE\" };\n\t\t}\n\t\tconst cap = device.capabilities?.find(c => c.type === capability && c.state === stateId);\n\t\tif (!cap) {\n\t\t\treturn { ok: false, reason: \"UNKNOWN_STATE_OR_CAPABILITY\" };\n\t\t}\n\t\treturn { ok: true };\n\t}\n\n\t/**\n\t * Fetch all devices from ioBroker states\n\t */\n\tprivate async fetchDevices(): Promise<Record<string, DeviceConfig>> {\n\t\tconst basePath = this.adapter.config.basePath;\n\t\tconst pattern = `${basePath}.devices.*`;\n\n\t\tconst states = await this.adapter.getForeignStatesAsync(pattern);\n\t\tconst devices: Record<string, DeviceConfig> = {};\n\n\t\t// Parse configs first\n\t\tfor (const [id, state] of Object.entries(states)) {\n\t\t\tif (!state?.val) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst deviceId = id.substring(`${basePath}.devices.`.length);\n\n\t\t\ttry {\n\t\t\t\tconst config = JSON.parse(state.val as string) as DeviceConfig;\n\t\t\t\tdevices[deviceId] = config;\n\t\t\t} catch {\n\t\t\t\tthis.adapter.log.warn(`Failed to parse device config for ${deviceId}`);\n\t\t\t}\n\t\t}\n\n\t\t// Collect all state IDs to fetch\n\t\tconst stateIds = new Set<string>();\n\t\tfor (const device of Object.values(devices)) {\n\t\t\tif (device.capabilities) {\n\t\t\t\tfor (const cap of device.capabilities) {\n\t\t\t\t\tif (cap.state) {\n\t\t\t\t\t\tstateIds.add(cap.state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fetch current values for all states\n\t\tif (stateIds.size > 0) {\n\t\t\tconst idArray = Array.from(stateIds);\n\n\t\t\t// Fetch in parallel\n\t\t\tawait Promise.all(\n\t\t\t\tidArray.map(async oid => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst state = await this.adapter.getForeignStateAsync(oid);\n\t\t\t\t\t\tif (state && state.val !== undefined && state.val !== null) {\n\t\t\t\t\t\t\tfor (const device of Object.values(devices)) {\n\t\t\t\t\t\t\t\tif (device.capabilities) {\n\t\t\t\t\t\t\t\t\tfor (const cap of device.capabilities) {\n\t\t\t\t\t\t\t\t\t\tif (cap.state === oid) {\n\t\t\t\t\t\t\t\t\t\t\tcap.value = state.val;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.adapter.log.warn(`Failed to fetch state ${oid}: ${(error as Error).message}`);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn devices;\n\t}\n\n\t/**\n\t * Fetch all rooms from ioBroker states\n\t */\n\tprivate async fetchRooms(): Promise<Record<string, RoomConfig>> {\n\t\tconst basePath = this.adapter.config.basePath;\n\t\tconst pattern = `${basePath}.rooms.*`;\n\n\t\tconst states = await this.adapter.getForeignStatesAsync(pattern);\n\t\tconst rooms: Record<string, RoomConfig> = {};\n\t\tconst metricStateIds = new Set<string>();\n\n\t\tfor (const [id, state] of Object.entries(states)) {\n\t\t\tif (!state?.val) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst roomId = id.substring(`${basePath}.rooms.`.length);\n\n\t\t\ttry {\n\t\t\t\tconst config = JSON.parse(state.val as string) as RoomConfig;\n\t\t\t\t// normalize metrics ids\n\t\t\t\tif (config.metrics && Array.isArray(config.metrics)) {\n\t\t\t\t\tconfig.metrics = config.metrics.map(m => {\n\t\t\t\t\t\tconst metric = { ...m };\n\t\t\t\t\t\tif (!metric.id) {\n\t\t\t\t\t\t\tmetric.id = metric.state || metric.type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!metric.label) {\n\t\t\t\t\t\t\tmetric.label = metric.type || metric.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (metric.state) {\n\t\t\t\t\t\t\tmetricStateIds.add(metric.state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn metric;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\trooms[roomId] = config;\n\t\t\t} catch (error) {\n\t\t\t\tthis.adapter.log.warn(`Failed to parse room config for ${roomId}: ${(error as Error).message}`);\n\t\t\t}\n\t\t}\n\n\t\t// fetch metric values\n\t\tif (metricStateIds.size > 0) {\n\t\t\tconst idArray = Array.from(metricStateIds);\n\t\t\tawait Promise.all(\n\t\t\t\tidArray.map(async oid => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst state = await this.adapter.getForeignStateAsync(oid);\n\t\t\t\t\t\tif (state) {\n\t\t\t\t\t\t\tfor (const room of Object.values(rooms)) {\n\t\t\t\t\t\t\t\tif (room.metrics) {\n\t\t\t\t\t\t\t\t\tfor (const metric of room.metrics) {\n\t\t\t\t\t\t\t\t\t\tif (metric.state === oid) {\n\t\t\t\t\t\t\t\t\t\t\tmetric.value = state.val;\n\t\t\t\t\t\t\t\t\t\t\tmetric.ts = state.ts ? new Date(state.ts).toISOString() : undefined;\n\t\t\t\t\t\t\t\t\t\t\tmetric.status =\n\t\t\t\t\t\t\t\t\t\t\t\tstate.val === undefined || state.val === null ? \"nodata\" : metric.status || \"ok\";\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.adapter.log.warn(`Failed to fetch metric state ${oid}: ${(error as Error).message}`);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn rooms;\n\t}\n\n\t/**\n\t * Fetch all scenes from cron_scenes adapter\n\t */\n\tprivate async fetchScenes(): Promise<Record<string, SceneConfig>> {\n\t\tconst scenesPath = this.adapter.config.scenesPath || \"cron_scenes.0.jobs\";\n\t\tconst pattern = `${scenesPath}.*`;\n\n\t\tconst states = await this.adapter.getForeignStatesAsync(pattern);\n\t\tconst scenes: Record<string, SceneConfig> = {};\n\t\tconst statusMap: Record<string, any> = {};\n\n\t\t// Parse states - separate config and status states\n\t\tfor (const [id, state] of Object.entries(states)) {\n\t\t\tif (!state?.val) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst relativeId = id.substring(scenesPath.length + 1);\n\n\t\t\t// Skip .trigger states\n\t\t\tif (relativeId.endsWith(\".trigger\")) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Parse .status states\n\t\t\tif (relativeId.endsWith(\".status\")) {\n\t\t\t\tconst sceneId = relativeId.slice(0, -7); // Remove '.status'\n\t\t\t\ttry {\n\t\t\t\t\tstatusMap[sceneId] = typeof state.val === \"string\" ? JSON.parse(state.val) : state.val;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.warn(`Failed to parse status for scene ${sceneId}: ${(error as Error).message}`);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Main scene config state (no dot in relativeId means it's a root state)\n\t\t\tif (!relativeId.includes(\".\")) {\n\t\t\t\tconst sceneId = relativeId;\n\t\t\t\ttry {\n\t\t\t\t\tconst config = typeof state.val === \"string\" ? JSON.parse(state.val) : state.val;\n\n\t\t\t\t\t// Build SceneConfig from cron_scenes config\n\t\t\t\t\tscenes[sceneId] = {\n\t\t\t\t\t\tname: config.name || sceneId,\n\t\t\t\t\t\ttype: config.type || \"recurring\",\n\t\t\t\t\t\tactive: config.active || false,\n\t\t\t\t\t\tcron: config.cron,\n\t\t\t\t\t\ttargets: (config.targets || []).map((t: any) => ({\n\t\t\t\t\t\t\tid: t.id,\n\t\t\t\t\t\t\tvalue: t.value,\n\t\t\t\t\t\t\ttype: t.type,\n\t\t\t\t\t\t\tdescription: t.description,\n\t\t\t\t\t\t\tdelay: t.delay,\n\t\t\t\t\t\t})),\n\t\t\t\t\t\ttriggerState: config.triggerState,\n\t\t\t\t\t\ttriggerValue: config.triggerValue,\n\t\t\t\t\t\tdebounce: config.debounce,\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tthis.adapter.log.warn(`Failed to parse scene config for ${sceneId}: ${(error as Error).message}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Merge status information into scenes\n\t\tfor (const [sceneId, scene] of Object.entries(scenes)) {\n\t\t\tconst status = statusMap[sceneId];\n\t\t\tif (status) {\n\t\t\t\tscene.lastRun = status.lastRun;\n\t\t\t\tscene.nextRun = status.nextRun;\n\t\t\t\tscene.hasError = !!status.error;\n\t\t\t\tscene.errorMessage = status.error;\n\t\t\t}\n\t\t}\n\n\t\treturn scenes;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
