{
  "version": 3,
  "sources": ["../../../src/lib/services/snapshot-service.ts"],
  "sourcesContent": ["/* eslint-disable jsdoc/require-param, jsdoc/require-jsdoc */\n\nimport type { DeviceConfig, RoomConfig, SnapshotPayload } from \"../websocket/types\";\n\n/**\n * Minimal adapter interface needed for snapshot building.\n */\nexport interface SnapshotAdapterDeps {\n\tlog: {\n\t\tdebug: (msg: string) => void;\n\t\tinfo: (msg: string) => void;\n\t\twarn: (msg: string) => void;\n\t\terror: (msg: string) => void;\n\t};\n\tconfig: {\n\t\tbasePath: string;\n\t};\n\tgetForeignStatesAsync: (pattern: string) => Promise<Record<string, ioBroker.State | null | undefined>>;\n\tgetForeignStateAsync: (id: string) => Promise<ioBroker.State | null | undefined>;\n\tsubscribeForeignStates: (pattern: string) => void;\n}\n\nexport class SnapshotService {\n\tprivate readonly adapter: SnapshotAdapterDeps;\n\n\tconstructor(adapter: SnapshotAdapterDeps) {\n\t\tthis.adapter = adapter;\n\t}\n\n\t/**\n\t * Build snapshot (devices + rooms) with provided seq reference\n\t */\n\tpublic async buildSnapshot(seq: number): Promise<SnapshotPayload> {\n\t\tconst [devices, rooms] = await Promise.all([this.getDevices(), this.getRooms()]);\n\t\treturn { devices, rooms, seq };\n\t}\n\n\tpublic async getDevices(): Promise<Record<string, DeviceConfig>> {\n\t\treturn this.fetchDevices();\n\t}\n\n\tpublic async getRooms(): Promise<Record<string, RoomConfig>> {\n\t\treturn this.fetchRooms();\n\t}\n\n\tpublic async validateSetState(\n\t\tdeviceId: string,\n\t\tcapability: string,\n\t\tstateId: string,\n\t): Promise<{ ok: boolean; reason?: string }> {\n\t\tconst devices = await this.fetchDevices();\n\t\tconst device = devices[deviceId];\n\t\tif (!device) {\n\t\t\treturn { ok: false, reason: \"UNKNOWN_DEVICE\" };\n\t\t}\n\t\tconst cap = device.capabilities?.find(c => c.type === capability && c.state === stateId);\n\t\tif (!cap) {\n\t\t\treturn { ok: false, reason: \"UNKNOWN_STATE_OR_CAPABILITY\" };\n\t\t}\n\t\treturn { ok: true };\n\t}\n\n\t/**\n\t * Fetch all devices from ioBroker states\n\t */\n\tprivate async fetchDevices(): Promise<Record<string, DeviceConfig>> {\n\t\tconst basePath = this.adapter.config.basePath;\n\t\tconst pattern = `${basePath}.devices.*`;\n\n\t\tconst states = await this.adapter.getForeignStatesAsync(pattern);\n\t\tconst devices: Record<string, DeviceConfig> = {};\n\n\t\t// Parse configs first\n\t\tfor (const [id, state] of Object.entries(states)) {\n\t\t\tif (!state?.val) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst deviceId = id.substring(`${basePath}.devices.`.length);\n\n\t\t\ttry {\n\t\t\t\tconst config = JSON.parse(state.val as string) as DeviceConfig;\n\t\t\t\tdevices[deviceId] = config;\n\t\t\t} catch {\n\t\t\t\tthis.adapter.log.warn(`Failed to parse device config for ${deviceId}`);\n\t\t\t}\n\t\t}\n\n\t\t// Collect all state IDs to fetch\n\t\tconst stateIds = new Set<string>();\n\t\tfor (const device of Object.values(devices)) {\n\t\t\tif (device.capabilities) {\n\t\t\t\tfor (const cap of device.capabilities) {\n\t\t\t\t\tif (cap.state) {\n\t\t\t\t\t\tstateIds.add(cap.state);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Fetch current values for all states\n\t\tif (stateIds.size > 0) {\n\t\t\tconst idArray = Array.from(stateIds);\n\n\t\t\t// Fetch in parallel\n\t\t\tawait Promise.all(\n\t\t\t\tidArray.map(async oid => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst state = await this.adapter.getForeignStateAsync(oid);\n\t\t\t\t\t\tif (state && state.val !== undefined && state.val !== null) {\n\t\t\t\t\t\t\tfor (const device of Object.values(devices)) {\n\t\t\t\t\t\t\t\tif (device.capabilities) {\n\t\t\t\t\t\t\t\t\tfor (const cap of device.capabilities) {\n\t\t\t\t\t\t\t\t\t\tif (cap.state === oid) {\n\t\t\t\t\t\t\t\t\t\t\tcap.value = state.val;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.adapter.log.warn(`Failed to fetch state ${oid}: ${(error as Error).message}`);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn devices;\n\t}\n\n\t/**\n\t * Fetch all rooms from ioBroker states\n\t */\n\tprivate async fetchRooms(): Promise<Record<string, RoomConfig>> {\n\t\tconst basePath = this.adapter.config.basePath;\n\t\tconst pattern = `${basePath}.rooms.*`;\n\n\t\tconst states = await this.adapter.getForeignStatesAsync(pattern);\n\t\tconst rooms: Record<string, RoomConfig> = {};\n\t\tconst metricStateIds = new Set<string>();\n\n\t\tfor (const [id, state] of Object.entries(states)) {\n\t\t\tif (!state?.val) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst roomId = id.substring(`${basePath}.rooms.`.length);\n\n\t\t\ttry {\n\t\t\t\tconst config = JSON.parse(state.val as string) as RoomConfig;\n\t\t\t\t// normalize metrics ids\n\t\t\t\tif (config.metrics && Array.isArray(config.metrics)) {\n\t\t\t\t\tconfig.metrics = config.metrics.map(m => {\n\t\t\t\t\t\tconst metric = { ...m };\n\t\t\t\t\t\tif (!metric.id) {\n\t\t\t\t\t\t\tmetric.id = metric.state || metric.type;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!metric.label) {\n\t\t\t\t\t\t\tmetric.label = metric.type || metric.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (metric.state) {\n\t\t\t\t\t\t\tmetricStateIds.add(metric.state);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn metric;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\trooms[roomId] = config;\n\t\t\t} catch (error) {\n\t\t\t\tthis.adapter.log.warn(`Failed to parse room config for ${roomId}: ${(error as Error).message}`);\n\t\t\t}\n\t\t}\n\n\t\t// fetch metric values\n\t\tif (metricStateIds.size > 0) {\n\t\t\tconst idArray = Array.from(metricStateIds);\n\t\t\tawait Promise.all(\n\t\t\t\tidArray.map(async oid => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst state = await this.adapter.getForeignStateAsync(oid);\n\t\t\t\t\t\tif (state) {\n\t\t\t\t\t\t\tfor (const room of Object.values(rooms)) {\n\t\t\t\t\t\t\t\tif (room.metrics) {\n\t\t\t\t\t\t\t\t\tfor (const metric of room.metrics) {\n\t\t\t\t\t\t\t\t\t\tif (metric.state === oid) {\n\t\t\t\t\t\t\t\t\t\t\tmetric.value = state.val;\n\t\t\t\t\t\t\t\t\t\t\tmetric.ts = state.ts ? new Date(state.ts).toISOString() : undefined;\n\t\t\t\t\t\t\t\t\t\t\tmetric.status =\n\t\t\t\t\t\t\t\t\t\t\t\tstate.val === undefined || state.val === null ? \"nodata\" : metric.status || \"ok\";\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tthis.adapter.log.warn(`Failed to fetch metric state ${oid}: ${(error as Error).message}`);\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\treturn rooms;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
