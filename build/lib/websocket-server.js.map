{
  "version": 3,
  "sources": ["../../src/lib/websocket-server.ts"],
  "sourcesContent": ["/**\n * WebSocket Server for Home Controller Adapter\n *\n * Provides a WebSocket API for clients to:\n * - Register with the adapter\n * - Fetch devices and rooms\n * - (Future) Subscribe to state changes\n */\n\nimport { WebSocket, WebSocketServer as WSServer } from \"ws\";\nimport type { IncomingMessage } from \"http\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport type {\n\tBaseMessage,\n\tClientMessage,\n\tConnectedClient,\n\tRegisteredResponse,\n\tDevicesResponse,\n\tGetRoomsRequest,\n\tGetSnapshotRequest,\n\tRoomsResponse,\n\tHelpRequest,\n\tHelpResponse,\n\tSnapshotResponse,\n\tInitialSnapshotResponse,\n\tStateChangeMessage,\n\tErrorMessage,\n\tErrorCode,\n} from \"./websocket/types\";\nimport { SnapshotService } from \"./services/snapshot-service\";\nimport { ErrorCodes } from \"./websocket/types\";\n\n// Re-export for convenience\nexport { ErrorCodes } from \"./websocket/types\";\n\n/**\n * Adapter interface - subset of ioBroker adapter methods we need\n */\ninterface AdapterInterface {\n\tlog: {\n\t\tdebug: (msg: string) => void;\n\t\tinfo: (msg: string) => void;\n\t\twarn: (msg: string) => void;\n\t\terror: (msg: string) => void;\n\t};\n\tconfig: {\n\t\tbasePath: string;\n\t\twsPort: number;\n\t\tauthMode?: \"none\" | \"basic\";\n\t\tauthUser?: string;\n\t\tauthPassword?: string;\n\t\tdefaultSubscription?: \"all\" | \"none\";\n\t\tmaxEventsPerSecond?: number;\n\t};\n\tgetForeignStatesAsync: (pattern: string) => Promise<Record<string, ioBroker.State | null | undefined>>;\n\tgetForeignStateAsync: (id: string) => Promise<ioBroker.State | null | undefined>;\n\tsubscribeForeignStates: (pattern: string) => void;\n}\n\n/**\n * WebSocket Server class for Home Controller\n */\nexport class HomeControllerWebSocketServer {\n\tprivate wss: WSServer | null = null;\n\tprivate clients: Map<WebSocket, ConnectedClient> = new Map();\n\tprivate adapter: AdapterInterface;\n\tprivate serverVersion = \"0.0.1\";\n\tprivate protocolVersion = \"1.0\";\n\tprivate schemaVersion = \"1.0\";\n\tprivate seqCounter = 0;\n\tprivate snapshotService: SnapshotService;\n\tprivate heartbeatInterval: NodeJS.Timeout | null = null;\n\tprivate readonly pingIntervalMs = 28000;\n\tprivate readonly pingTimeoutMs = 10000;\n\tprivate socketMeta: WeakMap<WebSocket, { isAlive: boolean; idleTimer?: NodeJS.Timeout }> = new WeakMap();\n\tprivate onClientChangeCallback: ((clients: ConnectedClient[]) => void) | null = null;\n\n\t// Map stateId -> list of capabilities that use it\n\tprivate stateMap: Map<string, Array<{ deviceId: string; capability: string }>> = new Map();\n\n\tconstructor(adapter: AdapterInterface) {\n\t\tthis.adapter = adapter;\n\t\tthis.snapshotService = new SnapshotService(adapter);\n\t}\n\n\t/**\n\t * Set callback for when clients connect/disconnect\n\t */\n\tpublic onClientChange(callback: (clients: ConnectedClient[]) => void): void {\n\t\tthis.onClientChangeCallback = callback;\n\t}\n\n\t/**\n\t * Notify about client changes\n\t */\n\tprivate notifyClientChange(): void {\n\t\tif (this.onClientChangeCallback) {\n\t\t\tthis.onClientChangeCallback(this.getConnectedClients());\n\t\t}\n\t}\n\n\t/**\n\t * Start the WebSocket server\n\t */\n\tpublic start(): void {\n\t\tthis.wss = new WSServer({\n\t\t\tport: this.adapter.config.wsPort,\n\t\t\tperMessageDeflate: true,\n\t\t});\n\n\t\tthis.wss.on(\"connection\", (ws: WebSocket, req: IncomingMessage) => {\n\t\t\tconst auth = this.authenticate(req);\n\t\t\tif (!auth.ok) {\n\t\t\t\tthis.adapter.log.warn(`Rejected connection: ${auth.reason ?? \"auth failed\"}`);\n\t\t\t\tws.close(auth.closeCode ?? 4001, auth.reason ?? \"AUTH_FAILED\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.handleConnection(ws, req);\n\t\t});\n\n\t\t// Initial subscription to all known states\n\t\tthis.subscribeToAllStates();\n\n\t\tthis.wss.on(\"error\", (error: Error) => {\n\t\t\tthis.adapter.log.error(`WebSocket server error: ${error.message}`);\n\t\t});\n\n\t\tthis.heartbeatInterval = setInterval(() => this.checkHeartbeats(), this.pingIntervalMs);\n\n\t\tthis.adapter.log.info(`WebSocket server started on port ${this.adapter.config.wsPort}`);\n\t}\n\n\t/**\n\t * Subscribe to all states defined in devices\n\t */\n\tpublic async subscribeToAllStates(): Promise<void> {\n\t\ttry {\n\t\t\t// Re-fetch devices to get fresh config\n\t\t\tconst devices = await this.snapshotService.getDevices();\n\n\t\t\tthis.stateMap.clear();\n\t\t\tconst statesToSubscribe = new Set<string>();\n\n\t\t\tfor (const [deviceId, config] of Object.entries(devices)) {\n\t\t\t\tif (config.capabilities) {\n\t\t\t\t\tfor (const cap of config.capabilities) {\n\t\t\t\t\t\tif (cap.state) {\n\t\t\t\t\t\t\tstatesToSubscribe.add(cap.state);\n\n\t\t\t\t\t\t\t// Add to map\n\t\t\t\t\t\t\tconst existing = this.stateMap.get(cap.state) || [];\n\t\t\t\t\t\t\texisting.push({ deviceId, capability: cap.type });\n\t\t\t\t\t\t\tthis.stateMap.set(cap.state, existing);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Subscribe to each state\n\t\t\tfor (const oid of statesToSubscribe) {\n\t\t\t\tthis.adapter.subscribeForeignStates(oid);\n\t\t\t}\n\n\t\t\tthis.adapter.log.info(`Subscribed to ${statesToSubscribe.size} states for real-time updates`);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.error(`Failed to subscribe to states: ${(error as Error).message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Handle state change from adapter\n\t */\n\tpublic handleStateChange(id: string, state: ioBroker.State): void {\n\t\tconst affected = this.stateMap.get(id);\n\t\tif (affected && affected.length > 0) {\n\t\t\tfor (const item of affected) {\n\t\t\t\tthis.broadcastStateChange(item.deviceId, item.capability, id, state.val, state.ts);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Broadcast state change to all connected clients\n\t */\n\tprivate broadcastStateChange(deviceId: string, capability: string, stateId: string, value: any, ts: number): void {\n\t\tconst message: StateChangeMessage = {\n\t\t\ttype: \"stateChange\",\n\t\t\tid: undefined, // Notification has no request ID\n\t\t\tpayload: {\n\t\t\t\tdeviceId,\n\t\t\t\tcapability,\n\t\t\t\tstate: stateId,\n\t\t\t\tvalue,\n\t\t\t\ttimestamp: new Date(ts).toISOString(),\n\t\t\t},\n\t\t};\n\n\t\t// Send to all connected clients\n\t\tfor (const ws of this.clients.keys()) {\n\t\t\tthis.send(ws, message);\n\t\t}\n\t}\n\n\t/**\n\t * Stop the WebSocket server\n\t */\n\tpublic stop(): void {\n\t\tif (this.wss) {\n\t\t\tif (this.heartbeatInterval) {\n\t\t\t\tclearInterval(this.heartbeatInterval);\n\t\t\t\tthis.heartbeatInterval = null;\n\t\t\t}\n\t\t\t// Close all client connections\n\t\t\tfor (const ws of this.clients.keys()) {\n\t\t\t\tws.close(1001, \"Server shutting down\");\n\t\t\t}\n\t\t\tthis.clients.clear();\n\n\t\t\tthis.wss.close();\n\t\t\tthis.wss = null;\n\t\t\tthis.adapter.log.info(\"WebSocket server stopped\");\n\t\t}\n\t}\n\n\t/**\n\t * Get number of connected clients\n\t */\n\tpublic getClientCount(): number {\n\t\treturn this.clients.size;\n\t}\n\n\t/**\n\t * Get list of connected clients (for admin UI)\n\t */\n\tpublic getConnectedClients(): ConnectedClient[] {\n\t\treturn Array.from(this.clients.values()).filter(c => c.isRegistered);\n\t}\n\n\t/**\n\t * Disconnect a client by ID\n\t */\n\tpublic disconnectClient(clientId: string): boolean {\n\t\tfor (const [ws, client] of this.clients.entries()) {\n\t\t\tif (client.id === clientId) {\n\t\t\t\tthis.adapter.log.info(`Disconnecting client ${client.name} (${clientId}) by admin request`);\n\t\t\t\tws.close(1000, \"Disconnected by administrator\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Handle new WebSocket connection\n\t */\n\tprivate handleConnection(ws: WebSocket, _req: IncomingMessage): void {\n\t\tthis.adapter.log.debug(\"New WebSocket connection\");\n\n\t\tthis.socketMeta.set(ws, { isAlive: true });\n\t\tws.on(\"pong\", () => {\n\t\t\tconst meta = this.socketMeta.get(ws);\n\t\t\tif (meta) {\n\t\t\t\tmeta.isAlive = true;\n\t\t\t}\n\t\t});\n\n\t\t// Store client as unregistered initially\n\t\tthis.clients.set(ws, {\n\t\t\tid: \"\",\n\t\t\tname: \"\",\n\t\t\tversion: \"\",\n\t\t\tclientType: \"\",\n\t\t\tconnectedAt: new Date(),\n\t\t\tisRegistered: false,\n\t\t\trecentRequests: [],\n\t\t});\n\n\t\tws.on(\"message\", (data: Buffer) => {\n\t\t\tthis.handleMessage(ws, data);\n\t\t});\n\n\t\tws.on(\"close\", () => {\n\t\t\tconst client = this.clients.get(ws);\n\t\t\tif (client?.isRegistered) {\n\t\t\t\tthis.adapter.log.info(`Client disconnected: ${client.name} (${client.id})`);\n\t\t\t} else {\n\t\t\t\tthis.adapter.log.debug(\"Unregistered client disconnected\");\n\t\t\t}\n\t\t\tthis.clients.delete(ws);\n\t\t\tconst meta = this.socketMeta.get(ws);\n\t\t\tif (meta?.idleTimer) {\n\t\t\t\tclearTimeout(meta.idleTimer);\n\t\t\t}\n\t\t\tthis.socketMeta.delete(ws);\n\t\t\tthis.notifyClientChange();\n\t\t});\n\n\t\tws.on(\"error\", (error: Error) => {\n\t\t\tthis.adapter.log.warn(`WebSocket client error: ${error.message}`);\n\t\t});\n\t}\n\n\t/**\n\t * Handle incoming message from client\n\t */\n\tprivate handleMessage(ws: WebSocket, data: Buffer): void {\n\t\tlet message: BaseMessage;\n\n\t\ttry {\n\t\t\tmessage = JSON.parse(data.toString()) as BaseMessage;\n\t\t} catch {\n\t\t\tthis.sendError(ws, undefined, ErrorCodes.INVALID_MESSAGE, \"Invalid JSON\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (!message.type) {\n\t\t\tthis.sendError(ws, message.id, ErrorCodes.INVALID_MESSAGE, \"Missing message type\");\n\t\t\treturn;\n\t\t}\n\n\t\tthis.adapter.log.debug(`Received message: ${message.type}`);\n\n\t\t// Log the request for debugging\n\t\tthis.logRequest(ws, message.type, message.id);\n\n\t\t// Route message to handler\n\t\tswitch (message.type) {\n\t\t\tcase \"register\":\n\t\t\t\tthis.handleRegister(ws, message);\n\t\t\t\tbreak;\n\t\t\tcase \"getDevices\":\n\t\t\t\tvoid this.handleGetDevices(ws, message);\n\t\t\t\tbreak;\n\t\t\tcase \"getRooms\":\n\t\t\t\tvoid this.handleGetRooms(ws, message as GetRoomsRequest);\n\t\t\t\tbreak;\n\t\t\tcase \"getSnapshot\":\n\t\t\t\tvoid this.handleGetSnapshot(ws, message as GetSnapshotRequest);\n\t\t\t\tbreak;\n\t\t\tcase \"help\":\n\t\t\t\tthis.handleHelp(ws, message as HelpRequest);\n\t\t\t\tbreak;\n\t\t\tcase \"subscribe\":\n\t\t\tcase \"unsubscribe\":\n\t\t\t\t// Handle subscriptions (implemented but not fully utilized yet)\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.sendError(ws, message.id, ErrorCodes.UNKNOWN_TYPE, `Unknown message type: ${message.type}`);\n\t\t}\n\t}\n\n\t/**\n\t * Handle help request\n\t */\n\tprivate handleHelp(ws: WebSocket, message: HelpRequest): void {\n\t\tconst response: HelpResponse = {\n\t\t\ttype: \"help\",\n\t\t\tid: message.id,\n\t\t\tpayload: {\n\t\t\t\tcommands: [\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: \"register\",\n\t\t\t\t\t\tdescription: \"Register a client with the server\",\n\t\t\t\t\t\texample: {\n\t\t\t\t\t\t\ttype: \"register\",\n\t\t\t\t\t\t\tid: \"req-1\",\n\t\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\t\tclientName: \"My Client\",\n\t\t\t\t\t\t\t\tclientVersion: \"1.0.0\",\n\t\t\t\t\t\t\t\tclientType: \"mobile\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: \"getDevices\",\n\t\t\t\t\t\tdescription: \"Get all available devices\",\n\t\t\t\t\t\texample: {\n\t\t\t\t\t\t\ttype: \"getDevices\",\n\t\t\t\t\t\t\tid: \"req-2\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: \"getRooms\",\n\t\t\t\t\t\tdescription: \"Get all available rooms\",\n\t\t\t\t\t\texample: {\n\t\t\t\t\t\t\ttype: \"getRooms\",\n\t\t\t\t\t\t\tid: \"req-3\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tcommand: \"help\",\n\t\t\t\t\t\tdescription: \"Get available commands\",\n\t\t\t\t\t\texample: {\n\t\t\t\t\t\t\ttype: \"help\",\n\t\t\t\t\t\t\tid: \"req-4\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t},\n\t\t};\n\n\t\tthis.send(ws, response);\n\t}\n\n\tprivate updateTimeout: NodeJS.Timeout | null = null;\n\n\t/**\n\t * Trigger a throttled update for logs\n\t */\n\tprivate triggerLogUpdate(): void {\n\t\tif (this.updateTimeout) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.updateTimeout = setTimeout(() => {\n\t\t\tthis.updateTimeout = null;\n\t\t\tthis.notifyClientChange();\n\t\t}, 2000);\n\t}\n\n\t/**\n\t * Log a request from a client\n\t */\n\tprivate logRequest(ws: WebSocket, type: string, id?: string): void {\n\t\tconst client = this.clients.get(ws);\n\t\tif (client) {\n\t\t\tclient.recentRequests.unshift({\n\t\t\t\ttimestamp: new Date(),\n\t\t\t\ttype: type,\n\t\t\t\tid: id,\n\t\t\t});\n\n\t\t\t// Keep only last 10\n\t\t\tif (client.recentRequests.length > 10) {\n\t\t\t\tclient.recentRequests.pop();\n\t\t\t}\n\n\t\t\t// Update state to show logs in Admin UI\n\t\t\t// Use throttled update to avoid flooding ioBroker with state changes\n\t\t\tthis.triggerLogUpdate();\n\t\t}\n\t}\n\n\t/**\n\t * Handle client registration\n\t */\n\tprivate handleRegister(ws: WebSocket, message: BaseMessage): void {\n\t\t// Cast to RegisterRequest to access payload\n\t\tconst regMsg = message as ClientMessage & { type: \"register\" };\n\t\tconst { clientName, clientVersion, clientType } = regMsg.payload;\n\t\tconst clientId = uuidv4();\n\n\t\t// Update client info\n\t\tconst client: ConnectedClient = {\n\t\t\tid: clientId,\n\t\t\tname: clientName || \"Unknown\",\n\t\t\tversion: clientVersion || \"0.0.0\",\n\t\t\tclientType: clientType || \"other\",\n\t\t\tconnectedAt: new Date(),\n\t\t\tisRegistered: true,\n\t\t\trecentRequests: [],\n\t\t};\n\t\tthis.clients.set(ws, client);\n\n\t\tthis.adapter.log.info(`Client registered: ${client.name} v${client.version} (${clientId})`);\n\n\t\tconst response: RegisteredResponse = {\n\t\t\ttype: \"registered\",\n\t\t\tid: message.id,\n\t\t\tpayload: {\n\t\t\t\tclientId,\n\t\t\t\tserverVersion: this.serverVersion,\n\t\t\t\tprotocolVersion: this.protocolVersion,\n\t\t\t\tschemaVersion: this.schemaVersion,\n\t\t\t\tcapabilities: [\"devices\", \"rooms\", \"stateChange\", \"subscribe\", \"setState\", \"batch\", \"compression\"],\n\t\t\t\tlimits: {\n\t\t\t\t\tmaxMsgBytes: 131072,\n\t\t\t\t\tmaxEventsPerSecond: this.adapter.config.maxEventsPerSecond ?? 50,\n\t\t\t\t\tsupportsBatch: true,\n\t\t\t\t\tsupportsCompression: true,\n\t\t\t\t\tdefaultSubscription: this.adapter.config.defaultSubscription ?? \"all\",\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\tthis.send(ws, response);\n\t\tvoid this.sendInitialSnapshot(ws);\n\t\tthis.notifyClientChange();\n\t}\n\n\t/**\n\t * Handle getDevices request\n\t */\n\tprivate async handleGetDevices(ws: WebSocket, message: BaseMessage): Promise<void> {\n\t\tconst client = this.clients.get(ws);\n\t\tif (!client?.isRegistered) {\n\t\t\tthis.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst devices = await this.snapshotService.getDevices();\n\n\t\t\tconst response: DevicesResponse = {\n\t\t\t\ttype: \"devices\",\n\t\t\t\tid: message.id,\n\t\t\t\tpayload: { devices },\n\t\t\t};\n\n\t\t\tthis.send(ws, response);\n\t\t\tthis.adapter.log.debug(`Sent ${Object.keys(devices).length} devices to ${client.name}`);\n\t\t} catch (error) {\n\t\t\tthis.sendError(\n\t\t\t\tws,\n\t\t\t\tmessage.id,\n\t\t\t\tErrorCodes.INTERNAL_ERROR,\n\t\t\t\t`Failed to fetch devices: ${(error as Error).message}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Handle getRooms request\n\t */\n\tprivate async handleGetRooms(ws: WebSocket, message: BaseMessage): Promise<void> {\n\t\tconst client = this.clients.get(ws);\n\t\tif (!client?.isRegistered) {\n\t\t\tthis.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst rooms = await this.snapshotService.getRooms();\n\n\t\t\tconst response: RoomsResponse = {\n\t\t\t\ttype: \"rooms\",\n\t\t\t\tid: message.id,\n\t\t\t\tpayload: { rooms },\n\t\t\t};\n\n\t\t\tthis.send(ws, response);\n\t\t\tthis.adapter.log.debug(`Sent ${Object.keys(rooms).length} rooms to ${client.name}`);\n\t\t} catch (error) {\n\t\t\tthis.sendError(\n\t\t\t\tws,\n\t\t\t\tmessage.id,\n\t\t\t\tErrorCodes.INTERNAL_ERROR,\n\t\t\t\t`Failed to fetch rooms: ${(error as Error).message}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Handle getSnapshot request\n\t */\n\tprivate async handleGetSnapshot(ws: WebSocket, message: BaseMessage): Promise<void> {\n\t\tconst client = this.clients.get(ws);\n\t\tif (!client?.isRegistered) {\n\t\t\tthis.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst seq = this.nextSeq();\n\t\t\tconst snapshot = await this.snapshotService.buildSnapshot(seq);\n\t\t\tconst response: SnapshotResponse = {\n\t\t\t\ttype: \"snapshot\",\n\t\t\t\tid: message.id,\n\t\t\t\tpayload: {\n\t\t\t\t\t...snapshot,\n\t\t\t\t},\n\t\t\t\tseq,\n\t\t\t};\n\t\t\tthis.send(ws, response);\n\t\t} catch (error) {\n\t\t\tthis.sendError(\n\t\t\t\tws,\n\t\t\t\tmessage.id,\n\t\t\t\tErrorCodes.INTERNAL_ERROR,\n\t\t\t\t`Failed to fetch snapshot: ${(error as Error).message}`,\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Send message to client\n\t */\n\tprivate send(ws: WebSocket, message: BaseMessage): void {\n\t\tif (ws.readyState === WebSocket.OPEN) {\n\t\t\tconst enriched: BaseMessage = {\n\t\t\t\t...message,\n\t\t\t\tseq: message.seq ?? this.nextSeq(),\n\t\t\t\tts: message.ts ?? new Date().toISOString(),\n\t\t\t\tversion: message.version ?? this.schemaVersion,\n\t\t\t};\n\t\t\tws.send(JSON.stringify(enriched));\n\t\t}\n\t}\n\n\t/**\n\t * Send error message to client\n\t */\n\tprivate sendError(ws: WebSocket, id: string | undefined, code: ErrorCode, message: string): void {\n\t\tconst errorMsg: ErrorMessage = {\n\t\t\ttype: \"error\",\n\t\t\tid,\n\t\t\terror: { code, message },\n\t\t};\n\t\tthis.send(ws, errorMsg);\n\t}\n\n\t/**\n\t * Send initial snapshot after registration\n\t */\n\tprivate async sendInitialSnapshot(ws: WebSocket): Promise<void> {\n\t\tconst client = this.clients.get(ws);\n\t\tif (!client?.isRegistered) {\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tconst seq = this.nextSeq();\n\t\t\tconst snapshot = await this.snapshotService.buildSnapshot(seq);\n\t\t\tconst response: InitialSnapshotResponse = {\n\t\t\t\ttype: \"initialSnapshot\",\n\t\t\t\tpayload: { ...snapshot },\n\t\t\t\tseq,\n\t\t\t};\n\t\t\tthis.send(ws, response);\n\t\t} catch (error) {\n\t\t\tthis.adapter.log.warn(`Failed to send initialSnapshot: ${(error as Error).message}`);\n\t\t}\n\t}\n\n\t/**\n\t * Authenticate incoming connection (Basic or none)\n\t */\n\tprivate authenticate(req: IncomingMessage): { ok: boolean; closeCode?: number; reason?: string } {\n\t\tconst mode = this.adapter.config.authMode ?? \"none\";\n\t\tif (mode === \"none\") {\n\t\t\treturn { ok: true };\n\t\t}\n\n\t\tif (mode === \"basic\") {\n\t\t\tconst header = req.headers.authorization;\n\t\t\tif (!header || !header.startsWith(\"Basic \")) {\n\t\t\t\treturn { ok: false, closeCode: 4001, reason: \"AUTH_FAILED\" };\n\t\t\t}\n\n\t\t\tconst token = header.substring(\"Basic \".length);\n\t\t\tconst decoded = Buffer.from(token, \"base64\").toString(\"utf8\");\n\t\t\tconst [user, pass] = decoded.split(\":\");\n\t\t\tif (!user || pass === undefined) {\n\t\t\t\treturn { ok: false, closeCode: 4001, reason: \"AUTH_FAILED\" };\n\t\t\t}\n\n\t\t\tconst expectedUser = this.adapter.config.authUser;\n\t\t\tconst expectedPass = this.adapter.config.authPassword;\n\t\t\tif (expectedUser && expectedPass) {\n\t\t\t\tif (user === expectedUser && pass === expectedPass) {\n\t\t\t\t\treturn { ok: true };\n\t\t\t\t}\n\t\t\t\treturn { ok: false, closeCode: 4001, reason: \"AUTH_FAILED\" };\n\t\t\t}\n\n\t\t\t// If no credentials configured, allow but warn\n\t\t\tthis.adapter.log.warn(\n\t\t\t\t\"Auth mode 'basic' is enabled but no credentials are configured; allowing connection.\",\n\t\t\t);\n\t\t\treturn { ok: true };\n\t\t}\n\n\t\treturn { ok: false, closeCode: 4004, reason: \"PROTOCOL_VERSION_UNSUPPORTED\" };\n\t}\n\n\t/**\n\t * Heartbeat loop: ping and close idle sockets\n\t */\n\tprivate checkHeartbeats(): void {\n\t\tfor (const ws of this.clients.keys()) {\n\t\t\tconst meta = this.socketMeta.get(ws);\n\t\t\tif (!meta) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!meta.isAlive) {\n\t\t\t\tws.close(4008, \"IDLE_TIMEOUT\");\n\t\t\t\tthis.clients.delete(ws);\n\t\t\t\tif (meta.idleTimer) {\n\t\t\t\t\tclearTimeout(meta.idleTimer);\n\t\t\t\t}\n\t\t\t\tthis.socketMeta.delete(ws);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmeta.isAlive = false;\n\t\t\tif (ws.readyState === WebSocket.OPEN) {\n\t\t\t\tws.ping();\n\t\t\t\tif (meta.idleTimer) {\n\t\t\t\t\tclearTimeout(meta.idleTimer);\n\t\t\t\t}\n\t\t\t\tmeta.idleTimer = setTimeout(() => {\n\t\t\t\t\tconst stillMeta = this.socketMeta.get(ws);\n\t\t\t\t\tif (stillMeta && !stillMeta.isAlive && ws.readyState === WebSocket.OPEN) {\n\t\t\t\t\t\tws.close(4008, \"IDLE_TIMEOUT\");\n\t\t\t\t\t\tthis.clients.delete(ws);\n\t\t\t\t\t\tthis.socketMeta.delete(ws);\n\t\t\t\t\t}\n\t\t\t\t}, this.pingTimeoutMs);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Generate next sequence number\n\t */\n\tprivate nextSeq(): number {\n\t\tthis.seqCounter += 1;\n\t\treturn this.seqCounter;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["import_types", "WSServer", "uuidv4"]
}
