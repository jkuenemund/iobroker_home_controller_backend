{
  "version": 3,
  "sources": ["../../src/lib/websocket-server.ts"],
  "sourcesContent": ["/**\n * WebSocket Server for Home Controller Adapter\n *\n * Provides a WebSocket API for clients to:\n * - Register with the adapter\n * - Fetch devices and rooms\n * - (Future) Subscribe to state changes\n */\n\nimport { WebSocket, WebSocketServer as WSServer } from \"ws\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport type {\n    BaseMessage,\n    ClientMessage,\n    ConnectedClient,\n    DeviceConfig,\n    RegisterRequest,\n    RegisteredResponse,\n    DevicesResponse,\n    GetDevicesRequest,\n    GetRoomsRequest,\n    RoomConfig,\n    RoomsResponse,\n    HelpRequest,\n    HelpResponse,\n    ErrorCodes,\n    ErrorMessage,\n} from \"./types/websocket-types\";\n\n// Re-export for convenience\nexport { ErrorCodes } from \"./types/websocket-types\";\n\n/**\n * Adapter interface - subset of ioBroker adapter methods we need\n */\ninterface AdapterInterface {\n    log: {\n        debug: (msg: string) => void;\n        info: (msg: string) => void;\n        warn: (msg: string) => void;\n        error: (msg: string) => void;\n    };\n    config: {\n        basePath: string;\n        wsPort: number;\n    };\n    getForeignStatesAsync: (pattern: string) => Promise<Record<string, ioBroker.State | null | undefined>>;\n    getForeignStateAsync: (id: string) => Promise<ioBroker.State | null | undefined>;\n}\n\n/**\n * WebSocket Server class for Home Controller\n */\nexport class HomeControllerWebSocketServer {\n    private wss: WSServer | null = null;\n    private clients: Map<WebSocket, ConnectedClient> = new Map();\n    private adapter: AdapterInterface;\n    private serverVersion = \"0.0.1\";\n    private onClientChangeCallback: ((clients: ConnectedClient[]) => void) | null = null;\n\n    constructor(adapter: AdapterInterface) {\n        this.adapter = adapter;\n    }\n\n    /**\n     * Set callback for when clients connect/disconnect\n     */\n    public onClientChange(callback: (clients: ConnectedClient[]) => void): void {\n        this.onClientChangeCallback = callback;\n    }\n\n    /**\n     * Notify about client changes\n     */\n    private notifyClientChange(): void {\n        if (this.onClientChangeCallback) {\n            this.onClientChangeCallback(this.getConnectedClients());\n        }\n    }\n\n    /**\n     * Start the WebSocket server\n     */\n    public start(): void {\n        const port = this.adapter.config.wsPort || 8082;\n\n        this.wss = new WSServer({ port });\n\n        this.wss.on(\"connection\", (ws: WebSocket) => {\n            this.handleConnection(ws);\n        });\n\n        this.wss.on(\"error\", (error: Error) => {\n            this.adapter.log.error(`WebSocket server error: ${error.message}`);\n        });\n\n        this.adapter.log.info(`WebSocket server started on port ${port}`);\n    }\n\n    /**\n     * Stop the WebSocket server\n     */\n    public stop(): void {\n        if (this.wss) {\n            // Close all client connections\n            for (const ws of this.clients.keys()) {\n                ws.close(1001, \"Server shutting down\");\n            }\n            this.clients.clear();\n\n            this.wss.close();\n            this.wss = null;\n            this.adapter.log.info(\"WebSocket server stopped\");\n        }\n    }\n\n    /**\n     * Get number of connected clients\n     */\n    public getClientCount(): number {\n        return this.clients.size;\n    }\n\n    /**\n     * Get list of connected clients (for admin UI)\n     */\n    public getConnectedClients(): ConnectedClient[] {\n        return Array.from(this.clients.values()).filter(c => c.isRegistered);\n    }\n\n    /**\n     * Disconnect a client by ID\n     */\n    public disconnectClient(clientId: string): boolean {\n        for (const [ws, client] of this.clients.entries()) {\n            if (client.id === clientId) {\n                this.adapter.log.info(`Disconnecting client ${client.name} (${clientId}) by admin request`);\n                ws.close(1000, \"Disconnected by administrator\");\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Handle new WebSocket connection\n     */\n    private handleConnection(ws: WebSocket): void {\n        this.adapter.log.debug(\"New WebSocket connection\");\n\n        // Store client as unregistered initially\n        this.clients.set(ws, {\n            id: \"\",\n            name: \"\",\n            version: \"\",\n            clientType: \"\",\n            connectedAt: new Date(),\n            isRegistered: false,\n            recentRequests: [],\n        });\n\n        ws.on(\"message\", (data: Buffer) => {\n            this.handleMessage(ws, data);\n        });\n\n        ws.on(\"close\", () => {\n            const client = this.clients.get(ws);\n            if (client?.isRegistered) {\n                this.adapter.log.info(`Client disconnected: ${client.name} (${client.id})`);\n            } else {\n                this.adapter.log.debug(\"Unregistered client disconnected\");\n            }\n            this.clients.delete(ws);\n            this.notifyClientChange();\n        });\n\n        ws.on(\"error\", (error: Error) => {\n            this.adapter.log.warn(`WebSocket client error: ${error.message}`);\n        });\n    }\n\n    /**\n     * Handle incoming message from client\n     */\n    private handleMessage(ws: WebSocket, data: Buffer): void {\n        let message: BaseMessage;\n\n        try {\n            message = JSON.parse(data.toString()) as BaseMessage;\n        } catch {\n            this.sendError(ws, undefined, \"INVALID_MESSAGE\", \"Invalid JSON\");\n            return;\n        }\n\n        if (!message.type) {\n            this.sendError(ws, message.id, \"INVALID_MESSAGE\", \"Missing message type\");\n            return;\n        }\n\n        this.adapter.log.debug(`Received message: ${message.type}`);\n\n        // Log the request for debugging\n        this.logRequest(ws, message.type, message.id);\n\n        // Route message to handler\n        switch (message.type) {\n            case \"register\":\n                this.handleRegister(ws, message);\n                break;\n            case \"getDevices\":\n                this.handleGetDevices(ws, message);\n                break;\n            case \"getRooms\":\n                this.handleGetRooms(ws, message as GetRoomsRequest);\n                break;\n            case \"help\":\n                this.handleHelp(ws, message as HelpRequest);\n                break;\n            case \"subscribe\":\n            case \"unsubscribe\":\n                // Handle subscriptions (implemented but not fully utilized yet)\n                break;\n            default:\n                this.sendError(ws, message.id, \"UNKNOWN_TYPE\", `Unknown message type: ${message.type}`);\n        }\n    }\n\n    /**\n     * Handle help request\n     */\n    private handleHelp(ws: WebSocket, message: HelpRequest): void {\n        const response: HelpResponse = {\n            type: \"help\",\n            id: message.id,\n            payload: {\n                commands: [\n                    {\n                        command: \"register\",\n                        description: \"Register a client with the server\",\n                        example: {\n                            type: \"register\",\n                            id: \"req-1\",\n                            payload: {\n                                clientName: \"My Client\",\n                                clientVersion: \"1.0.0\",\n                                clientType: \"mobile\"\n                            }\n                        }\n                    },\n                    {\n                        command: \"getDevices\",\n                        description: \"Get all available devices\",\n                        example: {\n                            type: \"getDevices\",\n                            id: \"req-2\"\n                        }\n                    },\n                    {\n                        command: \"getRooms\",\n                        description: \"Get all available rooms\",\n                        example: {\n                            type: \"getRooms\",\n                            id: \"req-3\"\n                        }\n                    },\n                    {\n                        command: \"help\",\n                        description: \"Get available commands\",\n                        example: {\n                            type: \"help\",\n                            id: \"req-4\"\n                        }\n                    }\n                ]\n            }\n        };\n\n        this.send(ws, response);\n    }\n\n    private updateTimeout: NodeJS.Timeout | null = null;\n\n    /**\n     * Trigger a throttled update for logs\n     */\n    private triggerLogUpdate(): void {\n        if (this.updateTimeout) return;\n\n        this.updateTimeout = setTimeout(() => {\n            this.updateTimeout = null;\n            this.notifyClientChange();\n        }, 2000);\n    }\n\n    /**\n     * Log a request from a client\n     */\n    private logRequest(ws: WebSocket, type: string, id?: string): void {\n        const client = this.clients.get(ws);\n        if (client) {\n            client.recentRequests.unshift({\n                timestamp: new Date(),\n                type: type,\n                id: id\n            });\n\n            // Keep only last 10\n            if (client.recentRequests.length > 10) {\n                client.recentRequests.pop();\n            }\n\n            // Update state to show logs in Admin UI\n            // Use throttled update to avoid flooding ioBroker with state changes\n            this.triggerLogUpdate();\n        }\n    }\n\n    /**\n     * Handle client registration\n     */\n    private handleRegister(ws: WebSocket, message: BaseMessage): void {\n        // Cast to RegisterRequest to access payload\n        const regMsg = message as ClientMessage & { type: \"register\" };\n        const { clientName, clientVersion, clientType } = regMsg.payload;\n        const clientId = uuidv4();\n\n        // Update client info\n        const client: ConnectedClient = {\n            id: clientId,\n            name: clientName || \"Unknown\",\n            version: clientVersion || \"0.0.0\",\n            clientType: clientType || \"other\",\n            connectedAt: new Date(),\n            isRegistered: true,\n            recentRequests: [],\n        };\n        this.clients.set(ws, client);\n\n        this.adapter.log.info(`Client registered: ${client.name} v${client.version} (${clientId})`);\n\n        const response: RegisteredResponse = {\n            type: \"registered\",\n            id: message.id,\n            payload: {\n                clientId,\n                serverVersion: this.serverVersion,\n                capabilities: [\"devices\", \"rooms\"],\n            },\n        };\n\n        this.send(ws, response);\n        this.notifyClientChange();\n    }\n\n    /**\n     * Handle getDevices request\n     */\n    private async handleGetDevices(ws: WebSocket, message: BaseMessage): Promise<void> {\n        const client = this.clients.get(ws);\n        if (!client?.isRegistered) {\n            this.sendError(ws, message.id, \"NOT_REGISTERED\", \"Client must register first\");\n            return;\n        }\n\n        try {\n            const devices = await this.fetchDevices();\n\n            const response: DevicesResponse = {\n                type: \"devices\",\n                id: message.id,\n                payload: { devices },\n            };\n\n            this.send(ws, response);\n            this.adapter.log.debug(`Sent ${Object.keys(devices).length} devices to ${client.name}`);\n        } catch (error) {\n            this.sendError(ws, message.id, \"INTERNAL_ERROR\", `Failed to fetch devices: ${(error as Error).message}`);\n        }\n    }\n\n    /**\n     * Handle getRooms request\n     */\n    private async handleGetRooms(ws: WebSocket, message: BaseMessage): Promise<void> {\n        const client = this.clients.get(ws);\n        if (!client?.isRegistered) {\n            this.sendError(ws, message.id, \"NOT_REGISTERED\", \"Client must register first\");\n            return;\n        }\n\n        try {\n            const rooms = await this.fetchRooms();\n\n            const response: RoomsResponse = {\n                type: \"rooms\",\n                id: message.id,\n                payload: { rooms },\n            };\n\n            this.send(ws, response);\n            this.adapter.log.debug(`Sent ${Object.keys(rooms).length} rooms to ${client.name}`);\n        } catch (error) {\n            this.sendError(ws, message.id, \"INTERNAL_ERROR\", `Failed to fetch rooms: ${(error as Error).message}`);\n        }\n    }\n\n    /**\n     * Fetch all devices from ioBroker states\n     */\n    private async fetchDevices(): Promise<Record<string, DeviceConfig>> {\n        const basePath = this.adapter.config.basePath;\n        const pattern = `${basePath}.devices.*`;\n\n        const states = await this.adapter.getForeignStatesAsync(pattern);\n        const devices: Record<string, DeviceConfig> = {};\n\n        // Parse configs first\n        for (const [id, state] of Object.entries(states)) {\n            if (!state?.val) continue;\n\n            const deviceId = id.substring(`${basePath}.devices.`.length);\n\n            try {\n                const config = JSON.parse(state.val as string) as DeviceConfig;\n                devices[deviceId] = config;\n            } catch {\n                this.adapter.log.warn(`Failed to parse device config for ${deviceId}`);\n            }\n        }\n\n        // Collect all state IDs to fetch\n        const stateIds = new Set<string>();\n        for (const device of Object.values(devices)) {\n            if (device.capabilities) {\n                for (const cap of device.capabilities) {\n                    if (cap.state) {\n                        stateIds.add(cap.state);\n                    }\n                }\n            }\n        }\n\n        // Fetch current values for all states\n        if (stateIds.size > 0) {\n            const idArray = Array.from(stateIds);\n\n            // Fetch in parallel\n            await Promise.all(idArray.map(async (oid) => {\n                try {\n                    const state = await this.adapter.getForeignStateAsync(oid);\n                    if (state && state.val !== undefined && state.val !== null) {\n                        // Update matching capabilities\n                        // Note: A state ID might be used by multiple devices/capabilities\n                        for (const device of Object.values(devices)) {\n                            if (device.capabilities) {\n                                for (const cap of device.capabilities) {\n                                    if (cap.state === oid) {\n                                        cap.value = state.val;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                } catch (error) {\n                    this.adapter.log.warn(`Failed to fetch state ${oid}: ${(error as Error).message}`);\n                }\n            }));\n        }\n\n        return devices;\n    }\n\n    /**\n     * Fetch all rooms from ioBroker states\n     */\n    private async fetchRooms(): Promise<Record<string, RoomConfig>> {\n        const basePath = this.adapter.config.basePath;\n        const pattern = `${basePath}.rooms.*`;\n\n        const states = await this.adapter.getForeignStatesAsync(pattern);\n        const rooms: Record<string, RoomConfig> = {};\n\n        for (const [id, state] of Object.entries(states)) {\n            if (!state?.val) continue;\n\n            const roomId = id.substring(`${basePath}.rooms.`.length);\n\n            try {\n                const config = JSON.parse(state.val as string) as RoomConfig;\n                rooms[roomId] = config;\n            } catch (error) {\n                this.adapter.log.warn(`Failed to parse room config for ${roomId}: ${(error as Error).message}`);\n            }\n        }\n\n        return rooms;\n    }\n\n    /**\n     * Send message to client\n     */\n    private send(ws: WebSocket, message: BaseMessage): void {\n        if (ws.readyState === WebSocket.OPEN) {\n            ws.send(JSON.stringify(message));\n        }\n    }\n\n    /**\n     * Send error message to client\n     */\n    private sendError(\n        ws: WebSocket,\n        id: string | undefined,\n        code: keyof typeof ErrorCodes,\n        message: string,\n    ): void {\n        const errorMsg: ErrorMessage = {\n            type: \"error\",\n            id,\n            error: { code, message },\n        };\n        this.send(ws, errorMsg);\n    }\n}\n"],
  "mappings": "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",
  "names": ["WSServer", "uuidv4"]
}
