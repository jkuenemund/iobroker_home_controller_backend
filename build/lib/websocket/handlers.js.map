{
  "version": 3,
  "sources": ["../../../src/lib/websocket/handlers.ts"],
  "sourcesContent": ["import type { WebSocket } from \"ws\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport type {\n\tBaseMessage,\n\tConnectedClient,\n\tDevicesResponse,\n\tGetRoomsRequest,\n\tGetSnapshotRequest,\n\tHelpRequest,\n\tHelpResponse,\n\tInitialSnapshotResponse,\n\tRegisteredResponse,\n\tRoomsResponse,\n\tSnapshotResponse,\n\tSubscribeRequest,\n\tUnsubscribeRequest,\n\tStateChangeMessage,\n\tSetStateRequest,\n\tTriggerSceneRequest,\n\tSaveSceneRequest,\n\tDeleteSceneRequest,\n} from \"./types\";\nimport { ErrorCodes } from \"./types\";\nimport type { SnapshotService } from \"../services/snapshot-service\";\nimport type { SubscriptionRegistry } from \"./subscriptions\";\nimport type { AdapterInterface } from \"./adapter-interface\";\n\nexport interface HandlerContext {\n\tadapter: Pick<\n\t\tAdapterInterface,\n\t\t\"log\" | \"config\" | \"setForeignStateAsync\" | \"delForeignObjectAsync\" | \"extendForeignObjectAsync\"\n\t>;\n\tclients: Map<WebSocket, ConnectedClient>;\n\tsnapshotService: SnapshotService;\n\tnextSeq: () => number;\n\tgetSeq: () => number;\n\tserverVersion: string;\n\tprotocolVersion: string;\n\tschemaVersion: string;\n\tsubscriptions: SubscriptionRegistry;\n\tsend: (ws: WebSocket, message: BaseMessage) => void;\n\tsendError: (ws: WebSocket, id: string | undefined, code: string, message: string) => void;\n\tnotifyClientChange: () => void;\n}\n\nexport function handleRegister(ctx: HandlerContext, ws: WebSocket, message: BaseMessage): void {\n\tconst regMsg = message as BaseMessage & {\n\t\tpayload: any;\n\t};\n\tconst { clientName, clientVersion, clientType, lastSeqSeen } = regMsg.payload;\n\tconst currentSeq = ctx.getSeq();\n\tif (lastSeqSeen !== undefined && lastSeqSeen < currentSeq) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.RESYNC_REQUIRED, \"Snapshot required; lastSeqSeen stale\");\n\t}\n\tconst clientId = uuidv4();\n\tconst existing = ctx.clients.get(ws);\n\n\tconst client: ConnectedClient = {\n\t\tid: clientId,\n\t\tname: clientName || \"Unknown\",\n\t\tversion: clientVersion || \"0.0.0\",\n\t\tclientType: clientType || \"other\",\n\t\tconnectedAt: new Date(),\n\t\tisRegistered: true,\n\t\trecentRequests: [],\n\t\tauthUser: existing?.authUser,\n\t};\n\tctx.clients.set(ws, client);\n\t// apply default subscription strategy (all/none)\n\tctx.subscriptions.setDefault(ws);\n\n\tctx.adapter.log.info(`Client registered: ${client.name} v${client.version} (${clientId})`);\n\n\tconst response: RegisteredResponse = {\n\t\ttype: \"registered\",\n\t\tid: message.id,\n\t\tpayload: {\n\t\t\tclientId,\n\t\t\tserverVersion: ctx.serverVersion,\n\t\t\tprotocolVersion: ctx.protocolVersion,\n\t\t\tschemaVersion: ctx.schemaVersion,\n\t\t\tcapabilities: [\"devices\", \"rooms\", \"stateChange\", \"subscribe\", \"setState\", \"batch\", \"compression\"],\n\t\t\tlimits: {\n\t\t\t\tmaxMsgBytes: 131072,\n\t\t\t\tmaxEventsPerSecond: ctx.adapter.config.maxEventsPerSecond ?? 50,\n\t\t\t\tsupportsBatch: true,\n\t\t\t\tsupportsCompression: true,\n\t\t\t\tdefaultSubscription: ctx.adapter.config.defaultSubscription ?? \"all\",\n\t\t\t},\n\t\t},\n\t};\n\n\tctx.send(ws, response);\n\tvoid sendInitialSnapshot(ctx, ws);\n\tctx.notifyClientChange();\n}\n\nexport async function handleGetDevices(ctx: HandlerContext, ws: WebSocket, message: BaseMessage): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst devices = await ctx.snapshotService.getDevices();\n\t\tconst response: DevicesResponse = {\n\t\t\ttype: \"devices\",\n\t\t\tid: message.id,\n\t\t\tpayload: { devices },\n\t\t};\n\t\tctx.send(ws, response);\n\t\tctx.adapter.log.debug(`Sent ${Object.keys(devices).length} devices to ${client.name}`);\n\t} catch (error) {\n\t\tctx.sendError(\n\t\t\tws,\n\t\t\tmessage.id,\n\t\t\tErrorCodes.INTERNAL_ERROR,\n\t\t\t`Failed to fetch devices: ${(error as Error).message}`,\n\t\t);\n\t}\n}\n\nexport async function handleGetRooms(ctx: HandlerContext, ws: WebSocket, message: GetRoomsRequest): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst rooms = await ctx.snapshotService.getRooms();\n\t\tconst response: RoomsResponse = {\n\t\t\ttype: \"rooms\",\n\t\t\tid: message.id,\n\t\t\tpayload: { rooms },\n\t\t};\n\t\tctx.send(ws, response);\n\t\tctx.adapter.log.debug(`Sent ${Object.keys(rooms).length} rooms to ${client.name}`);\n\t} catch (error) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INTERNAL_ERROR, `Failed to fetch rooms: ${(error as Error).message}`);\n\t}\n}\n\nexport async function handleGetSnapshot(\n\tctx: HandlerContext,\n\tws: WebSocket,\n\tmessage: GetSnapshotRequest,\n): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst seq = ctx.nextSeq();\n\t\tconst snapshot = await ctx.snapshotService.buildSnapshot(seq);\n\t\tconst response: SnapshotResponse = {\n\t\t\ttype: \"snapshot\",\n\t\t\tid: message.id,\n\t\t\tpayload: { ...snapshot },\n\t\t\tseq,\n\t\t};\n\t\tctx.send(ws, response);\n\t} catch (error) {\n\t\tctx.sendError(\n\t\t\tws,\n\t\t\tmessage.id,\n\t\t\tErrorCodes.INTERNAL_ERROR,\n\t\t\t`Failed to fetch snapshot: ${(error as Error).message}`,\n\t\t);\n\t}\n}\n\nexport function handleHelp(ctx: HandlerContext, ws: WebSocket, message: HelpRequest): void {\n\tconst response: HelpResponse = {\n\t\ttype: \"help\",\n\t\tid: message.id,\n\t\tpayload: {\n\t\t\tcommands: [\n\t\t\t\t{\n\t\t\t\t\tcommand: \"register\",\n\t\t\t\t\tdescription: \"Register a client with the server\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"register\",\n\t\t\t\t\t\tid: \"req-1\",\n\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\tclientName: \"My Client\",\n\t\t\t\t\t\t\tclientVersion: \"1.0.0\",\n\t\t\t\t\t\t\tclientType: \"mobile\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcommand: \"getDevices\",\n\t\t\t\t\tdescription: \"Get all available devices\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"getDevices\",\n\t\t\t\t\t\tid: \"req-2\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcommand: \"getRooms\",\n\t\t\t\t\tdescription: \"Get all available rooms\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"getRooms\",\n\t\t\t\t\t\tid: \"req-3\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcommand: \"getSnapshot\",\n\t\t\t\t\tdescription: \"Get devices and rooms snapshot\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"getSnapshot\",\n\t\t\t\t\t\tid: \"req-4\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcommand: \"help\",\n\t\t\t\t\tdescription: \"Get available commands\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"help\",\n\t\t\t\t\t\tid: \"req-5\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcommand: \"subscribe\",\n\t\t\t\t\tdescription: \"Subscribe with filters\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"subscribe\",\n\t\t\t\t\t\tid: \"req-sub-1\",\n\t\t\t\t\t\tpayload: {\n\t\t\t\t\t\t\tdeviceIds: [\"livingroom_light\"],\n\t\t\t\t\t\t\tcapabilityTypes: [\"toggle\"],\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tcommand: \"unsubscribe\",\n\t\t\t\t\tdescription: \"Unsubscribe filters (empty to clear all)\",\n\t\t\t\t\texample: {\n\t\t\t\t\t\ttype: \"unsubscribe\",\n\t\t\t\t\t\tid: \"req-unsub-1\",\n\t\t\t\t\t\tpayload: {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t};\n\tctx.send(ws, response);\n}\n\nexport function handleSubscribe(\n\tctx: HandlerContext,\n\tws: WebSocket,\n\tmessage: SubscribeRequest | UnsubscribeRequest,\n): void {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\tconst filters = message.payload ?? {};\n\tif (message.type === \"subscribe\") {\n\t\tctx.subscriptions.subscribe(ws, filters);\n\t\tctx.send(ws, { type: \"subscribed\", id: message.id });\n\t} else {\n\t\tctx.subscriptions.unsubscribe(ws, filters);\n\t\tctx.send(ws, { type: \"unsubscribed\", id: message.id });\n\t}\n}\n\nexport function applySubscriptions(\n\tctx: HandlerContext,\n\tevent: StateChangeMessage,\n): Array<[WebSocket, StateChangeMessage]> {\n\tconst deliveries: Array<[WebSocket, StateChangeMessage]> = [];\n\tfor (const ws of ctx.clients.keys()) {\n\t\tif (ctx.subscriptions.shouldDeliver(ws, event, ctx.clients)) {\n\t\t\tdeliveries.push([ws, event]);\n\t\t}\n\t}\n\treturn deliveries;\n}\n\nexport async function handleSetState(ctx: HandlerContext, ws: WebSocket, message: SetStateRequest): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst validation = await ctx.snapshotService.validateSetState(\n\t\t\tmessage.payload.deviceId,\n\t\t\tmessage.payload.capability,\n\t\t\tmessage.payload.state,\n\t\t);\n\t\tif (!validation.ok) {\n\t\t\tctx.sendError(ws, message.id, ErrorCodes.PERMISSION_DENIED, validation.reason ?? \"Not allowed\");\n\t\t\treturn;\n\t\t}\n\n\t\tconst value = message.payload.value as ioBroker.SettableState | ioBroker.StateValue | ioBroker.State;\n\t\tawait ctx.adapter.setForeignStateAsync(message.payload.state, value, message.payload.ack ?? false);\n\t\t// respond with ack message (could be a stateChange later)\n\t\tctx.send(ws, { type: \"ack\", id: message.id });\n\t} catch (error) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INTERNAL_ERROR, `Failed to set state: ${(error as Error).message}`);\n\t}\n}\n\nexport async function handleTriggerScene(\n\tctx: HandlerContext,\n\tws: WebSocket,\n\tmessage: TriggerSceneRequest,\n): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\tconst { sceneId } = message.payload;\n\tif (!sceneId || typeof sceneId !== \"string\") {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INVALID_PAYLOAD, \"Invalid sceneId\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\t// Set trigger state to true\n\t\tconst triggerPath = `cron_scenes.0.jobs.${sceneId}.trigger`;\n\t\t// ack=false because the adapter will ack it\n\t\tawait ctx.adapter.setForeignStateAsync(triggerPath, true, false);\n\n\t\t// Send acknowledgment\n\t\tctx.send(ws, { type: \"ack\", id: message.id });\n\t\tctx.adapter.log.info(`Triggered scene ${sceneId} via WebSocket from ${client.name}`);\n\t} catch (error) {\n\t\tctx.sendError(\n\t\t\tws,\n\t\t\tmessage.id,\n\t\t\tErrorCodes.INTERNAL_ERROR,\n\t\t\t`Failed to trigger scene: ${(error as Error).message}`,\n\t\t);\n\t}\n}\n\n/**\n * Handle save scene request\n */\nexport async function handleSaveScene(ctx: HandlerContext, ws: WebSocket, message: SaveSceneRequest): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\tconst { sceneId, config } = message.payload;\n\tif (!sceneId || !config) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INVALID_PAYLOAD, \"Missing sceneId or config\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst statePath = `cron_scenes.0.jobs.${message.payload.sceneId}`;\n\n\t\t// Ensure the object exists using extendForeignObjectAsync (creates if not exists, updates if exists)\n\t\tawait ctx.adapter.extendForeignObjectAsync(statePath, {\n\t\t\ttype: \"state\",\n\t\t\tcommon: {\n\t\t\t\tname: message.payload.sceneId, // Using ID as name initially\n\t\t\t\ttype: \"string\", // JSON content is stored as string\n\t\t\t\trole: \"json\", // Role for JSON content\n\t\t\t\tread: true,\n\t\t\t\twrite: true,\n\t\t\t\tdesc: \"Created by home_controller\",\n\t\t\t},\n\t\t\tnative: {},\n\t\t});\n\n\t\t// Save as JSON string\n\t\tawait ctx.adapter.setForeignStateAsync(statePath, JSON.stringify(config), true);\n\n\t\tctx.send(ws, { type: \"ack\", id: message.id });\n\t\tctx.adapter.log.info(`Saved scene ${sceneId} via WebSocket from ${client.name}`);\n\t} catch (error) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INTERNAL_ERROR, `Failed to save scene: ${(error as Error).message}`);\n\t}\n}\n\nexport async function handleDeleteScene(\n\tctx: HandlerContext,\n\tws: WebSocket,\n\tmessage: DeleteSceneRequest,\n): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.NOT_REGISTERED, \"Client must register first\");\n\t\treturn;\n\t}\n\n\tconst { sceneId } = message.payload;\n\tif (!sceneId) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INVALID_PAYLOAD, \"Missing sceneId\");\n\t\treturn;\n\t}\n\n\ttry {\n\t\tconst objectPath = `cron_scenes.0.jobs.${sceneId}`;\n\t\tawait ctx.adapter.delForeignObjectAsync(objectPath);\n\n\t\tctx.send(ws, { type: \"ack\", id: message.id });\n\t\tctx.adapter.log.info(`Deleted scene ${sceneId} via WebSocket from ${client.name}`);\n\t} catch (error) {\n\t\tctx.sendError(ws, message.id, ErrorCodes.INTERNAL_ERROR, `Failed to delete scene: ${(error as Error).message}`);\n\t}\n}\n\nasync function sendInitialSnapshot(ctx: HandlerContext, ws: WebSocket): Promise<void> {\n\tconst client = ctx.clients.get(ws);\n\tif (!client?.isRegistered) {\n\t\treturn;\n\t}\n\ttry {\n\t\tconst seq = ctx.nextSeq();\n\t\tconst snapshot = await ctx.snapshotService.buildSnapshot(seq);\n\t\tconst response: InitialSnapshotResponse = {\n\t\t\ttype: \"initialSnapshot\",\n\t\t\tpayload: { ...snapshot },\n\t\t\tseq,\n\t\t};\n\t\tctx.send(ws, response);\n\t} catch (error) {\n\t\tctx.adapter.log.warn(`Failed to send initialSnapshot: ${(error as Error).message}`);\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,kBAA6B;AAqB7B,mBAA2B;AAuBpB,SAAS,eAAe,KAAqB,IAAe,SAA4B;AA7C/F;AA8CC,QAAM,SAAS;AAGf,QAAM,EAAE,YAAY,eAAe,YAAY,YAAY,IAAI,OAAO;AACtE,QAAM,aAAa,IAAI,OAAO;AAC9B,MAAI,gBAAgB,UAAa,cAAc,YAAY;AAC1D,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,iBAAiB,sCAAsC;AAAA,EACjG;AACA,QAAM,eAAW,YAAAA,IAAO;AACxB,QAAM,WAAW,IAAI,QAAQ,IAAI,EAAE;AAEnC,QAAM,SAA0B;AAAA,IAC/B,IAAI;AAAA,IACJ,MAAM,cAAc;AAAA,IACpB,SAAS,iBAAiB;AAAA,IAC1B,YAAY,cAAc;AAAA,IAC1B,aAAa,oBAAI,KAAK;AAAA,IACtB,cAAc;AAAA,IACd,gBAAgB,CAAC;AAAA,IACjB,UAAU,qCAAU;AAAA,EACrB;AACA,MAAI,QAAQ,IAAI,IAAI,MAAM;AAE1B,MAAI,cAAc,WAAW,EAAE;AAE/B,MAAI,QAAQ,IAAI,KAAK,sBAAsB,OAAO,IAAI,KAAK,OAAO,OAAO,KAAK,QAAQ,GAAG;AAEzF,QAAM,WAA+B;AAAA,IACpC,MAAM;AAAA,IACN,IAAI,QAAQ;AAAA,IACZ,SAAS;AAAA,MACR;AAAA,MACA,eAAe,IAAI;AAAA,MACnB,iBAAiB,IAAI;AAAA,MACrB,eAAe,IAAI;AAAA,MACnB,cAAc,CAAC,WAAW,SAAS,eAAe,aAAa,YAAY,SAAS,aAAa;AAAA,MACjG,QAAQ;AAAA,QACP,aAAa;AAAA,QACb,qBAAoB,SAAI,QAAQ,OAAO,uBAAnB,YAAyC;AAAA,QAC7D,eAAe;AAAA,QACf,qBAAqB;AAAA,QACrB,sBAAqB,SAAI,QAAQ,OAAO,wBAAnB,YAA0C;AAAA,MAChE;AAAA,IACD;AAAA,EACD;AAEA,MAAI,KAAK,IAAI,QAAQ;AACrB,OAAK,oBAAoB,KAAK,EAAE;AAChC,MAAI,mBAAmB;AACxB;AAEA,eAAsB,iBAAiB,KAAqB,IAAe,SAAqC;AAC/G,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,MAAI;AACH,UAAM,UAAU,MAAM,IAAI,gBAAgB,WAAW;AACrD,UAAM,WAA4B;AAAA,MACjC,MAAM;AAAA,MACN,IAAI,QAAQ;AAAA,MACZ,SAAS,EAAE,QAAQ;AAAA,IACpB;AACA,QAAI,KAAK,IAAI,QAAQ;AACrB,QAAI,QAAQ,IAAI,MAAM,QAAQ,OAAO,KAAK,OAAO,EAAE,MAAM,eAAe,OAAO,IAAI,EAAE;AAAA,EACtF,SAAS,OAAO;AACf,QAAI;AAAA,MACH;AAAA,MACA,QAAQ;AAAA,MACR,wBAAW;AAAA,MACX,4BAA6B,MAAgB,OAAO;AAAA,IACrD;AAAA,EACD;AACD;AAEA,eAAsB,eAAe,KAAqB,IAAe,SAAyC;AACjH,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,MAAI;AACH,UAAM,QAAQ,MAAM,IAAI,gBAAgB,SAAS;AACjD,UAAM,WAA0B;AAAA,MAC/B,MAAM;AAAA,MACN,IAAI,QAAQ;AAAA,MACZ,SAAS,EAAE,MAAM;AAAA,IAClB;AACA,QAAI,KAAK,IAAI,QAAQ;AACrB,QAAI,QAAQ,IAAI,MAAM,QAAQ,OAAO,KAAK,KAAK,EAAE,MAAM,aAAa,OAAO,IAAI,EAAE;AAAA,EAClF,SAAS,OAAO;AACf,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,0BAA2B,MAAgB,OAAO,EAAE;AAAA,EAC9G;AACD;AAEA,eAAsB,kBACrB,KACA,IACA,SACgB;AAChB,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,MAAI;AACH,UAAM,MAAM,IAAI,QAAQ;AACxB,UAAM,WAAW,MAAM,IAAI,gBAAgB,cAAc,GAAG;AAC5D,UAAM,WAA6B;AAAA,MAClC,MAAM;AAAA,MACN,IAAI,QAAQ;AAAA,MACZ,SAAS,EAAE,GAAG,SAAS;AAAA,MACvB;AAAA,IACD;AACA,QAAI,KAAK,IAAI,QAAQ;AAAA,EACtB,SAAS,OAAO;AACf,QAAI;AAAA,MACH;AAAA,MACA,QAAQ;AAAA,MACR,wBAAW;AAAA,MACX,6BAA8B,MAAgB,OAAO;AAAA,IACtD;AAAA,EACD;AACD;AAEO,SAAS,WAAW,KAAqB,IAAe,SAA4B;AAC1F,QAAM,WAAyB;AAAA,IAC9B,MAAM;AAAA,IACN,IAAI,QAAQ;AAAA,IACZ,SAAS;AAAA,MACR,UAAU;AAAA,QACT;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,YACJ,SAAS;AAAA,cACR,YAAY;AAAA,cACZ,eAAe;AAAA,cACf,YAAY;AAAA,YACb;AAAA,UACD;AAAA,QACD;AAAA,QACA;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,UACL;AAAA,QACD;AAAA,QACA;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,UACL;AAAA,QACD;AAAA,QACA;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,UACL;AAAA,QACD;AAAA,QACA;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,UACL;AAAA,QACD;AAAA,QACA;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,YACJ,SAAS;AAAA,cACR,WAAW,CAAC,kBAAkB;AAAA,cAC9B,iBAAiB,CAAC,QAAQ;AAAA,YAC3B;AAAA,UACD;AAAA,QACD;AAAA,QACA;AAAA,UACC,SAAS;AAAA,UACT,aAAa;AAAA,UACb,SAAS;AAAA,YACR,MAAM;AAAA,YACN,IAAI;AAAA,YACJ,SAAS,CAAC;AAAA,UACX;AAAA,QACD;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACA,MAAI,KAAK,IAAI,QAAQ;AACtB;AAEO,SAAS,gBACf,KACA,IACA,SACO;AAjQR;AAkQC,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AACA,QAAM,WAAU,aAAQ,YAAR,YAAmB,CAAC;AACpC,MAAI,QAAQ,SAAS,aAAa;AACjC,QAAI,cAAc,UAAU,IAAI,OAAO;AACvC,QAAI,KAAK,IAAI,EAAE,MAAM,cAAc,IAAI,QAAQ,GAAG,CAAC;AAAA,EACpD,OAAO;AACN,QAAI,cAAc,YAAY,IAAI,OAAO;AACzC,QAAI,KAAK,IAAI,EAAE,MAAM,gBAAgB,IAAI,QAAQ,GAAG,CAAC;AAAA,EACtD;AACD;AAEO,SAAS,mBACf,KACA,OACyC;AACzC,QAAM,aAAqD,CAAC;AAC5D,aAAW,MAAM,IAAI,QAAQ,KAAK,GAAG;AACpC,QAAI,IAAI,cAAc,cAAc,IAAI,OAAO,IAAI,OAAO,GAAG;AAC5D,iBAAW,KAAK,CAAC,IAAI,KAAK,CAAC;AAAA,IAC5B;AAAA,EACD;AACA,SAAO;AACR;AAEA,eAAsB,eAAe,KAAqB,IAAe,SAAyC;AA9RlH;AA+RC,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,MAAI;AACH,UAAM,aAAa,MAAM,IAAI,gBAAgB;AAAA,MAC5C,QAAQ,QAAQ;AAAA,MAChB,QAAQ,QAAQ;AAAA,MAChB,QAAQ,QAAQ;AAAA,IACjB;AACA,QAAI,CAAC,WAAW,IAAI;AACnB,UAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,oBAAmB,gBAAW,WAAX,YAAqB,aAAa;AAC9F;AAAA,IACD;AAEA,UAAM,QAAQ,QAAQ,QAAQ;AAC9B,UAAM,IAAI,QAAQ,qBAAqB,QAAQ,QAAQ,OAAO,QAAO,aAAQ,QAAQ,QAAhB,YAAuB,KAAK;AAEjG,QAAI,KAAK,IAAI,EAAE,MAAM,OAAO,IAAI,QAAQ,GAAG,CAAC;AAAA,EAC7C,SAAS,OAAO;AACf,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,wBAAyB,MAAgB,OAAO,EAAE;AAAA,EAC5G;AACD;AAEA,eAAsB,mBACrB,KACA,IACA,SACgB;AAChB,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,QAAM,EAAE,QAAQ,IAAI,QAAQ;AAC5B,MAAI,CAAC,WAAW,OAAO,YAAY,UAAU;AAC5C,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,iBAAiB,iBAAiB;AAC3E;AAAA,EACD;AAEA,MAAI;AAEH,UAAM,cAAc,sBAAsB,OAAO;AAEjD,UAAM,IAAI,QAAQ,qBAAqB,aAAa,MAAM,KAAK;AAG/D,QAAI,KAAK,IAAI,EAAE,MAAM,OAAO,IAAI,QAAQ,GAAG,CAAC;AAC5C,QAAI,QAAQ,IAAI,KAAK,mBAAmB,OAAO,uBAAuB,OAAO,IAAI,EAAE;AAAA,EACpF,SAAS,OAAO;AACf,QAAI;AAAA,MACH;AAAA,MACA,QAAQ;AAAA,MACR,wBAAW;AAAA,MACX,4BAA6B,MAAgB,OAAO;AAAA,IACrD;AAAA,EACD;AACD;AAKA,eAAsB,gBAAgB,KAAqB,IAAe,SAA0C;AACnH,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,QAAM,EAAE,SAAS,OAAO,IAAI,QAAQ;AACpC,MAAI,CAAC,WAAW,CAAC,QAAQ;AACxB,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,iBAAiB,2BAA2B;AACrF;AAAA,EACD;AAEA,MAAI;AACH,UAAM,YAAY,sBAAsB,QAAQ,QAAQ,OAAO;AAG/D,UAAM,IAAI,QAAQ,yBAAyB,WAAW;AAAA,MACrD,MAAM;AAAA,MACN,QAAQ;AAAA,QACP,MAAM,QAAQ,QAAQ;AAAA;AAAA,QACtB,MAAM;AAAA;AAAA,QACN,MAAM;AAAA;AAAA,QACN,MAAM;AAAA,QACN,OAAO;AAAA,QACP,MAAM;AAAA,MACP;AAAA,MACA,QAAQ,CAAC;AAAA,IACV,CAAC;AAGD,UAAM,IAAI,QAAQ,qBAAqB,WAAW,KAAK,UAAU,MAAM,GAAG,IAAI;AAE9E,QAAI,KAAK,IAAI,EAAE,MAAM,OAAO,IAAI,QAAQ,GAAG,CAAC;AAC5C,QAAI,QAAQ,IAAI,KAAK,eAAe,OAAO,uBAAuB,OAAO,IAAI,EAAE;AAAA,EAChF,SAAS,OAAO;AACf,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,yBAA0B,MAAgB,OAAO,EAAE;AAAA,EAC7G;AACD;AAEA,eAAsB,kBACrB,KACA,IACA,SACgB;AAChB,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,4BAA4B;AACrF;AAAA,EACD;AAEA,QAAM,EAAE,QAAQ,IAAI,QAAQ;AAC5B,MAAI,CAAC,SAAS;AACb,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,iBAAiB,iBAAiB;AAC3E;AAAA,EACD;AAEA,MAAI;AACH,UAAM,aAAa,sBAAsB,OAAO;AAChD,UAAM,IAAI,QAAQ,sBAAsB,UAAU;AAElD,QAAI,KAAK,IAAI,EAAE,MAAM,OAAO,IAAI,QAAQ,GAAG,CAAC;AAC5C,QAAI,QAAQ,IAAI,KAAK,iBAAiB,OAAO,uBAAuB,OAAO,IAAI,EAAE;AAAA,EAClF,SAAS,OAAO;AACf,QAAI,UAAU,IAAI,QAAQ,IAAI,wBAAW,gBAAgB,2BAA4B,MAAgB,OAAO,EAAE;AAAA,EAC/G;AACD;AAEA,eAAe,oBAAoB,KAAqB,IAA8B;AACrF,QAAM,SAAS,IAAI,QAAQ,IAAI,EAAE;AACjC,MAAI,EAAC,iCAAQ,eAAc;AAC1B;AAAA,EACD;AACA,MAAI;AACH,UAAM,MAAM,IAAI,QAAQ;AACxB,UAAM,WAAW,MAAM,IAAI,gBAAgB,cAAc,GAAG;AAC5D,UAAM,WAAoC;AAAA,MACzC,MAAM;AAAA,MACN,SAAS,EAAE,GAAG,SAAS;AAAA,MACvB;AAAA,IACD;AACA,QAAI,KAAK,IAAI,QAAQ;AAAA,EACtB,SAAS,OAAO;AACf,QAAI,QAAQ,IAAI,KAAK,mCAAoC,MAAgB,OAAO,EAAE;AAAA,EACnF;AACD;",
  "names": ["uuidv4"]
}
