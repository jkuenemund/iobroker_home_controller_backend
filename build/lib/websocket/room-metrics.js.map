{
  "version": 3,
  "sources": ["../../../src/lib/websocket/room-metrics.ts"],
  "sourcesContent": ["import { WebSocket } from \"ws\";\nimport type { BaseMessage, ConnectedClient, RoomMetric } from \"./types\";\nimport type { SnapshotService } from \"../services/snapshot-service\";\nimport type { SubscriptionRegistry } from \"./subscriptions\";\n\ninterface RoomMetricsDeps {\n\tadapter: {\n\t\tlog: {\n\t\t\tdebug: (msg: string) => void;\n\t\t\tinfo: (msg: string) => void;\n\t\t\twarn: (msg: string) => void;\n\t\t\terror: (msg: string) => void;\n\t\t};\n\t\tsubscribeForeignStates: (pattern: string) => void;\n\t\tgetForeignStateAsync: (id: string) => Promise<ioBroker.State | null | undefined>;\n\t\tconfig: {\n\t\t\troomMetricsBatchIntervalSec?: number;\n\t\t};\n\t};\n\tsnapshotService: SnapshotService;\n\tclients: Map<WebSocket, ConnectedClient>;\n\tsend: (ws: WebSocket, msg: BaseMessage) => void;\n\tsubscriptions: SubscriptionRegistry;\n}\n\ninterface MetricRef {\n\troomId: string;\n\tmetricId: string;\n\tunit?: string;\n\tlabel?: string;\n\ttype?: string;\n}\n\nexport class RoomMetricsManager {\n\tprivate readonly deps: RoomMetricsDeps;\n\tprivate readonly stateToMetric: Map<string, MetricRef> = new Map();\n\tprivate readonly buffer: Map<string, Map<string, { value: unknown; ts: string; status?: string; unit?: string; label?: string; type?: string }>> =\n\t\tnew Map();\n\tprivate flushTimer: NodeJS.Timeout | null = null;\n\tprivate readonly batchIntervalMs: number;\n\n\tconstructor(deps: RoomMetricsDeps) {\n\t\tthis.deps = deps;\n\t\tconst cfgSec = deps.adapter.config.roomMetricsBatchIntervalSec;\n\t\tthis.batchIntervalMs = cfgSec && cfgSec > 0 ? cfgSec * 1000 : 60_000;\n\t}\n\n\tpublic async subscribeToAllMetrics(): Promise<void> {\n\t\ttry {\n\t\t\tconst rooms = await this.deps.snapshotService.getRooms();\n\t\t\tthis.stateToMetric.clear();\n\t\t\tconst stateIds = new Set<string>();\n\n\t\t\tfor (const [roomId, room] of Object.entries(rooms)) {\n\t\t\t\tif (!room.metrics) continue;\n\t\t\t\tfor (const metricRaw of room.metrics) {\n\t\t\t\t\tconst metric = metricRaw as RoomMetric & { id?: string };\n\t\t\t\t\tif (!metric.state) continue;\n\t\t\t\t\tconst metricId = metric.id || metric.state || metric.type || `${roomId}_${Math.random()}`;\n\t\t\t\t\tthis.stateToMetric.set(metric.state, {\n\t\t\t\t\t\troomId,\n\t\t\t\t\t\tmetricId,\n\t\t\t\t\t\tunit: metric.unit,\n\t\t\t\t\t\tlabel: metric.label,\n\t\t\t\t\t\ttype: metric.type,\n\t\t\t\t\t});\n\t\t\t\t\tstateIds.add(metric.state);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const oid of stateIds) {\n\t\t\t\tthis.deps.adapter.subscribeForeignStates(oid);\n\t\t\t}\n\n\t\t\tthis.deps.adapter.log.info(`Subscribed to ${stateIds.size} room metric states`);\n\t\t} catch (error) {\n\t\t\tthis.deps.adapter.log.error(`Failed to subscribe to room metrics: ${(error as Error).message}`);\n\t\t}\n\t}\n\n\tpublic handleStateChange(id: string, state: ioBroker.State): void {\n\t\tconst ref = this.stateToMetric.get(id);\n\t\tif (!ref) return;\n\t\tconst ts = state.ts ? new Date(state.ts).toISOString() : new Date().toISOString();\n\t\tconst status = state.val === undefined || state.val === null ? \"nodata\" : \"ok\";\n\n\t\tlet roomEntry = this.buffer.get(ref.roomId);\n\t\tif (!roomEntry) {\n\t\t\troomEntry = new Map();\n\t\t\tthis.buffer.set(ref.roomId, roomEntry);\n\t\t}\n\t\troomEntry.set(ref.metricId, {\n\t\t\tvalue: state.val,\n\t\t\tts,\n\t\t\tstatus,\n\t\t\tunit: ref.unit,\n\t\t\tlabel: ref.label,\n\t\t\ttype: ref.type,\n\t\t});\n\n\t\tif (!this.flushTimer) {\n\t\t\tthis.flushTimer = setTimeout(() => this.flush(), this.batchIntervalMs);\n\t\t}\n\t}\n\n\tprivate flush(): void {\n\t\tthis.flushTimer = null;\n\t\tif (this.buffer.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst roomsPayload: Array<{\n\t\t\troomId: string;\n\t\t\tmetrics: Array<{\n\t\t\t\tid: string;\n\t\t\t\tvalue: unknown;\n\t\t\t\tts: string;\n\t\t\t\tstatus?: string;\n\t\t\t\tunit?: string;\n\t\t\t\tlabel?: string;\n\t\t\t\ttype?: string;\n\t\t\t}>;\n\t\t}> = [];\n\t\tfor (const [roomId, metricsMap] of this.buffer.entries()) {\n\t\t\tconst metrics: Array<{\n\t\t\t\tid: string;\n\t\t\t\tvalue: unknown;\n\t\t\t\tts: string;\n\t\t\t\tstatus?: string;\n\t\t\t\tunit?: string;\n\t\t\t\tlabel?: string;\n\t\t\t\ttype?: string;\n\t\t\t}> = [];\n\t\t\tfor (const [metricId, data] of metricsMap.entries()) {\n\t\t\t\tmetrics.push({\n\t\t\t\t\tid: metricId,\n\t\t\t\t\tvalue: data.value,\n\t\t\t\t\tts: data.ts,\n\t\t\t\t\tstatus: data.status as any,\n\t\t\t\t\tunit: data.unit,\n\t\t\t\t\tlabel: data.label,\n\t\t\t\t\ttype: data.type,\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (metrics.length > 0) {\n\t\t\t\troomsPayload.push({ roomId, metrics });\n\t\t\t}\n\t\t}\n\n\t\tif (roomsPayload.length === 0) {\n\t\t\tthis.buffer.clear();\n\t\t\treturn;\n\t\t}\n\n\t\tconst message: BaseMessage & {\n\t\t\ttype: \"roomMetricsUpdateBatch\";\n\t\t\tpayload: { rooms: typeof roomsPayload };\n\t\t} = {\n\t\t\ttype: \"roomMetricsUpdateBatch\",\n\t\t\tpayload: { rooms: roomsPayload },\n\t\t};\n\n\t\tfor (const ws of this.deps.clients.keys()) {\n\t\t\tif (this.deps.subscriptions.shouldDeliverRoom(ws, roomsPayload)) {\n\t\t\t\tthis.deps.send(ws, message);\n\t\t\t}\n\t\t}\n\n\t\tthis.buffer.clear();\n\t}\n}\n\n"],
  "mappings": "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",
  "names": []
}
